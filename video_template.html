<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Slide Studio Renderer</title>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind for styling (optional) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body {
            background-color: #1a1a1a;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }

        #canvas-container {
            position: relative;
            width: 960px;
            height: 540px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .hidden {
            display: none;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const SlideRenderer = () => {
            const [status, setStatus] = useState("Ready");
            const [progress, setProgress] = useState(0);
            const canvasRef = useRef(null);

            // Global Data injected by Streamlit
            // window.SLIDE_DATA = { slides: [ { image: "base64...", audio: "base64...", duration: 5.0, script: "..." } ] }
            const slides = window.SLIDE_DATA ? window.SLIDE_DATA.slides : [];

            const startRendering = async () => {
                if (!slides.length) {
                    setStatus("No slides to render");
                    return;
                }

                setStatus("Rendering...");
                const canvas = canvasRef.current;
                const ctx = canvas.getContext("2d");

                // Setup MediaRecorder
                const stream = canvas.captureStream(30); // 30 FPS
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const dest = audioCtx.createMediaStreamDestination();

                // Combine audio track into the stream
                stream.addTrack(dest.stream.getAudioTracks()[0]);

                const recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
                const chunks = [];

                recorder.ondataavailable = e => chunks.push(e.data);
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);

                    // Trigger Download
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'presentation.webm';
                    a.click();
                    setStatus("Download Started!");
                };

                recorder.start();

                // Playback Loop
                for (let i = 0; i < slides.length; i++) {
                    const slide = slides[i];
                    setStatus(`Playing Slide ${i + 1}/${slides.length}`);
                    setProgress(((i) / slides.length) * 100);

                    // 1. Load Image
                    const img = new Image();
                    img.src = slide.image;
                    await new Promise(r => img.onload = r);

                    // 2. Load Audio
                    const audioBuffer = await fetch(slide.audio)
                        .then(r => r.arrayBuffer())
                        .then(b => audioCtx.decodeAudioData(b));

                    const source = audioCtx.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(dest);
                    source.connect(audioCtx.destination); // Also play to speakers so user hears it

                    // 3. Draw & Play
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                    // Draw Caption (Optional)
                    ctx.fillStyle = "rgba(0,0,0,0.6)";
                    ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
                    ctx.fillStyle = "white";
                    ctx.font = "30px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText(slide.script, canvas.width / 2, canvas.height - 30);

                    source.start();

                    // Wait for audio to finish
                    await new Promise(r => source.onended = r);

                    // Small pause between slides
                    await new Promise(r => setTimeout(r, 500));
                }

                recorder.stop();
                setProgress(100);
            };

            return (
                <div className="flex flex-col items-center gap-4">
                    <h1 className="text-2xl font-bold">Video Renderer</h1>
                    <div id="canvas-container">
                        <canvas ref={canvasRef} width={1920} height={1080} />
                    </div>

                    <div className="w-full max-w-lg bg-gray-700 h-4 rounded-full">
                        <div className="bg-blue-500 h-4 rounded-full transition-all" style={{ width: `${progress}%` }}></div>
                    </div>

                    <p className="text-xl">{status}</p>

                    <button
                        onClick={startRendering}
                        className="px-6 py-2 bg-green-600 hover:bg-green-700 rounded text-white font-bold"
                    >
                        Start Rendering & Download
                    </button>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<SlideRenderer />);
    </script>
</body>

</html>